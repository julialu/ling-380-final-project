
29,May,2004



       
       urlLink    Test 
     

    


20,June,2004



       
      Replacing TabSheets with Frames - by Dan Miser  Rating:      Ratings: 107     Rate it   Abstract: Using TFrames, interfaces and inheritance, you can overcome the limitations of using TTabSheets in your application.   Introduction Using a TPageControl component helps separate your GUI by putting bits and pieces of related functionality on a single form. While this approach is very nice, putting all of the visual controls and code directly on the TTabsheets of the TPageControl can lead to a few problems, such as:  Increased unit size. This makes it harder to focus on the intent of the code.  Tabsheets are always created. This means the controls that are on the tabsheets are always created. This, in turn, means that you may encounter compilation problems as the unit gets too large, or you will find the run-time impact of memory, resources, and handles to be too severe.  Code is not logically separated. This makes it harder to reuse code that can be found inside the tabsheets.  Replacement of tabs. If you have a custom tab that only displays for one customer, you must add the tab and controls all in the same unit.  To solve these problems, this article will focus on a framework that will show you how to use TFrames, inheritance and interfaces to get your application all of the benefits of the TPageControl, without the drawbacks. Along the way, we'll also get rid of a couple of bugs that you would encounter if you created the framework from scratch.  Download the sample code for this article, and customize it for your project.   TFrame giveth and TFrame taketh away According to the Delphi help file, "TFrame is a container for components; it can be nested within forms or other frames.". Our goal is to have a TPageControl with many TTabsheets, and let each TTabsheet host a TFrame. Using this one bit of indirection, we address all of the drawbacks listed above. This thinking isn't new - it's been with us since Delphi 1 and TTabbedNotebook. People have searched for a "Best Practice" way of doing this, and in my mind, when working with TPageControl, Peter Below described the best approach. After changing it a bit, here is the first bit of code:   { Dynamic support for frame-based tabsheets } type   TFrameClass = class of TFrame;  procedure TSampleForm.FormCreate(Sender: TObject); begin   Tabsheet1.Tag := Integer(TFrame1);   Tabsheet2.Tag := Integer(TFrame2); end;  procedure TSampleForm.CreateFrame(ATabsheet: TTabSheet); var   frame: TFrame; begin   if GetFrame(ATabsheet) = nil then     if ATabsheet.Tag <> 0 then     begin       frame := TFrameClass(ATabsheet.Tag).Create(Self);       frame.Parent := ATabsheet;       frame.Align := alClient;     end; end;  procedure TSampleForm.DestroyFrame(ATabsheet: TTabsheet); var   frame: TFrame; begin   frame := GetFrame(ATabsheet);   if frame <> nil then     frame.Free; end;  function TSampleForm.GetFrame(ATabSheet: TTabsheet): TFrame; begin   if not Assigned(ATabsheet) then     ATabsheet := PageControl1.ActivePage;   Result := nil;   if Assigned(ATabsheet) and (ATabSheet.ControlCount <> 0 then     begin       // Pass on the desired parent HWND       frame := TFrameClass(ATabsheet.Tag).Create(Self, ATabsheet.Handle);        frame.Parent := ATabsheet;       frame.Align := alClient;     end; end;  By making these changes, the new framework works flawlessly across all 3 of the client options listed above.  Inheritance Now that we have all of the problems solved, let's focus on how to turn this into an easy-to-reuse solution. Instead of making each and every frame implement the IFrame interface, we can have a TBaseFrame class that will do that for us. If a frame needs special handling, we simply override the OnShow or OnHide events. TBaseFrame looks like this:   type   TBaseFrame = class(TFrame, IFrame)   private     { Private declarations }     FParentWnd: HWND;     procedure CMShowingChanged(var Message: TMessage); message CM_SHOWINGCHANGED;   protected     { Public declarations }     procedure OnShow; virtual;     procedure OnHide; virtual;     procedure CreateParams(var Params: TCreateParams); override;   public     constructor Create(AOwner: TComponent; AParentWnd: HWND); reintroduce; overload;   end;  type   TFrameClass = class of TBaseFrame;  implementation  {$R *.dfm}  { TBaseFrame } procedure TBaseFrame.CMShowingChanged(var Message: TMessage); begin   inherited;   SetFocus;   SelectFirst; // Put the focus to the first control in the frame end;  constructor TBaseFrame.Create(AOwner: TComponent; AParentWnd: HWND); begin   FParentWnd := AParentWnd;   Create(AOwner); // Let this call out to the child consructor, if overridden end;  procedure TBaseFrame.CreateParams(var Params: TCreateParams); begin   inherited CreateParams(Params);   if (Parent = nil) and IsLibrary and not (csDestroying in ComponentState) then     Params.WndParent := FParentWnd; end;  procedure TBaseFrame.OnShow; begin   // Empty end;  procedure TBaseFrame.OnHide; begin   // Empty end;  Creating a base frame (TBaseFrame) that does all of our work means that when we want to plug a new frame into a system, we do 2 things: create a new frame that descends from TBaseFrame and add a line of code to associate the tabsheet with the frame. Since a TFrame can host other TFrames, there's no limit to how involved the framework can become.   General notes Here are some things that need to be considered when using this framework:  Don't use TPageControl.OnChange/OnChanging and TTabsheet.OnEnter/OnExit - or at least be sure that those events don't require access to a frame that is destroyed.  Write your code so that frames do not talk to other frames.  Frames can talk back to the main form. Either use the main form's global variable, or extend the IFrame interface to have Get/SetParentForm methods.  When writing code that needs to access a specific frame, create a custom interface for that frame.  Some ideas for future enhancement of the framework are:  Create a custom TTabSheet designer that allows you to work with the Delphi IDE at design-time and automatically save out to a TFrame instead.  Create a descendant TPageControl that will automatically take care of the events and hookup of tab sheets.  About the Author Dan Miser is a long-time Delphi programmer, specializing in multi-tier technologies. He has written many magazine articles, been a contributing author to the "Delphi x Developer's Guide" series, acted as technical reviewer, and worked on many interesting products, both within and outside of Borland. Dan is currently working at TIP Technologies in Brookfield, WI. For a more in-depth look at Dan's life, see this interview by Clay Shannon.    --------------------------------------------------------------------------------   NOTE: The views and information expressed in this document represent those of its author(s) who are solely responsible for its content. Borland does not make or give any representation or warranty with respect to such content.     Votes   0 1 6 48 52     Responses: 107  Average: 4.41121   1=Poor, 5=Excellent   I have not rated this article. Rate it: 1 2 3 4 5           Add or View comments                    Rating   1 2 3 4 5              Article ID: 32047   Publish Date: May 07, 2004  Last Modified: May 07, 2004                     Help   Feedback   Home Pages   Newsgroups   Search         Made in Borland® Copyright© 1994-2004 Borland Software Corporation. All rights reserved. Legal Notices, Privacy Policy   
     

    



